{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenMod Documentation \u00b6 Welcome to the OpenMod Documentation. OpenMod is a .NET plugin framework. If you would like to install OpenMod, installation guides for the following platforms are available: Unturned If you want to make plugins for OpenMod, you can get started by reading the Making your first plugin page.","title":"Home"},{"location":"#openmod-documentation","text":"Welcome to the OpenMod Documentation. OpenMod is a .NET plugin framework. If you would like to install OpenMod, installation guides for the following platforms are available: Unturned If you want to make plugins for OpenMod, you can get started by reading the Making your first plugin page.","title":"OpenMod Documentation"},{"location":"development-guide/commands/","text":"Commands \u00b6 OpenMod provides a strong command framework. To create a command, simply create a class that inherits from one of these: Command (for universal plugins) UnityEngineCommand (for UnityEngine plugins) UnturnedCommand (for Unturned plugins) In this example, we will make a universal command: public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Note In the following examples no translations are used. See translations on information on how to integrate translation files. After that, add some metadata to describe our command and its usage: [Command(\"awesome\")] // The primary name for the command. Usually, it is defined as lowercase. [CommandAlias(\"awsm\")] // Add \"awsm\" as alias. [CommandAlias(\"aw\")] // Add \"aw\" as alias. [CommandDescription(\"My awesome command\")] // Description. Try to keep it short and simple. public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Finally implement OnExecuteAsync: [Command(\"awesome\")] [CommandAlias(\"awsm\")] [CommandAlias(\"aw\")] [CommandDescription(\"My awesome command\")] public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () // use UniTask instead of Task if derivered from UnityEngineCommand or UnturnedCommand { var actor = Context . Actor ; await actor . PrintMessageAsync ( \"You are awesome!\" ); // await PrintAsync(\"You are awesome\"); // alternatively, you can use this shortcut. } } Parameters \u00b6 When we handle commands, we usually also need to handle parameters. The command context provides a Parameter property. Let's use it: public async Task OnExecuteAsync () { // assume we want the command to be called like this: /awesome <player> <amount> // Parameters start from 0, so <player> index is 0, <amount> index is 1. var player = await Context . Parameters . GetAsync < string >( 0 ); var amount = await Context . Parameters . GetAsync < int >( 1 ); await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } After that, we need to describe how users can use the command. Add the syntax metadata to the command class: //... [CommandSyntax(\"<player> [amount] \")] // Describe the syntax/usage. Use <> for required arguments and [] for optional arguments. public class CommandAwesome : Command //... Restricting Command Actors \u00b6 If you are not developing universal plugins, you may want to limit who can execute commands. The [CommandActor(Type)] attribute allows you to specify such restrictions. For example, if you would like to restrict a command's usage to UnturnedUser and ConsoleActor, you could add the following: //... [CommandActor(typeof(UnturnedUser))] [CommandActor(typeof(ConsoleActor))] public class CommandAwesome : Command //... Exceptions \u00b6 Exceptions derived from UserFriendlyException are automatically caught by OpenMod and displayed to the user in a user-friendly way. These built-in exceptions available: NotEnoughPermissionException, can be thrown if the user does not have enough permission to execute an action. CommandWrongUsageException, can be thrown on wrong command usage. Displays correct usage based on command syntax. CommandIndexOutOfRangeException, thrown automatically by Parameters.Get if the given index is bigger than the arguments length. CommandParameterParseException, thrown automatically by Parameters.Get if the parameter could not be parsed to the expected type. CommandNotFoundException, thrown automatically if a command was not found. public async Task OnExecuteAsync () { var player = await Context . Parameters . GetAsync < string >( 0 ); var amount = await Context . Parameters . GetAsync < int >( 1 ); if ( amount < 1 ) { throw new UserFriendlyException ( \"Amount cannot be negative!\" ); } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } Command Permissions \u00b6 By design and for consistency reasons, you cannot define a command permission manually. OpenMod will automatically assign a permission to the command instead. You can use the help <yourcommand> command to figure out what the base permission for your command is. Assume you want to restrict the awesome command if the amount is more than 10. This is how you would do it: public async Task OnExecuteAsync () { var player = await Context . Parameters . GetAsync < string >( 0 ); var amount = await Context . Parameters . GetAsync < int >( 1 ); if ( amount > 10 && await CheckPermissionAsync ( \"MoreThan10\" ) != PermissionGrantResult . Grant ) { throw new NotEnoughPermissionException ( this , \"MoreThan10\" ); // displays an error message to the user } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } Adding Subcommands \u00b6 You can add subcommands to a command by using the [CommandParent] attribute. This allows OpenMod to discover your subcommands and provide additional help and tab autocompletion. The following command will execute when a user types \"/awesome more\". The CommandAwesome.OnExecuteAsync method will not execute in this case. [Command(\"more\")] [CommandDescription(\"My more awesome command\")] [CommandParent(typeof(CommandAwesome))] // set \"awesome\" as parent. public class CommandAwesomeMore : Command { public CommandAwesomeMore ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { // Note: Parameters do not include \"more\". // If you type \"/awesome more a\", Context.Parameters[0] will be equal to \"a\". await PrintAsync ( \"You are even more awesome!\" ); } } Best Practices \u00b6 Do not handle sub commands yourself (e.g. if(Context.Parameters[0] == \"add\") ). OpenMod cannot discover your subcommands and provide additional help or tab completion in that case. Do not hardcode messages. Instead, use translations so users can customize and translate your messages. When writing commands, keep in mind that any type of user could execute your command by default. Maybe a plugin adds a DiscordUser and someone from Discord executes your command. Try to write your commands in a way that works with all kinds of users or restrict the allowed actors as mentioned earlier. Do not manually check if an actor is allowed to execute a command (e.g. if(!(actor is UnturnedUser)) ). Always use [CommandActor(Type)] for such restrictions. It will automatically hide the command from actors who cannot execute them and give a consistent error message.","title":"Commands"},{"location":"development-guide/commands/#commands","text":"OpenMod provides a strong command framework. To create a command, simply create a class that inherits from one of these: Command (for universal plugins) UnityEngineCommand (for UnityEngine plugins) UnturnedCommand (for Unturned plugins) In this example, we will make a universal command: public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Note In the following examples no translations are used. See translations on information on how to integrate translation files. After that, add some metadata to describe our command and its usage: [Command(\"awesome\")] // The primary name for the command. Usually, it is defined as lowercase. [CommandAlias(\"awsm\")] // Add \"awsm\" as alias. [CommandAlias(\"aw\")] // Add \"aw\" as alias. [CommandDescription(\"My awesome command\")] // Description. Try to keep it short and simple. public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Finally implement OnExecuteAsync: [Command(\"awesome\")] [CommandAlias(\"awsm\")] [CommandAlias(\"aw\")] [CommandDescription(\"My awesome command\")] public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () // use UniTask instead of Task if derivered from UnityEngineCommand or UnturnedCommand { var actor = Context . Actor ; await actor . PrintMessageAsync ( \"You are awesome!\" ); // await PrintAsync(\"You are awesome\"); // alternatively, you can use this shortcut. } }","title":"Commands"},{"location":"development-guide/commands/#parameters","text":"When we handle commands, we usually also need to handle parameters. The command context provides a Parameter property. Let's use it: public async Task OnExecuteAsync () { // assume we want the command to be called like this: /awesome <player> <amount> // Parameters start from 0, so <player> index is 0, <amount> index is 1. var player = await Context . Parameters . GetAsync < string >( 0 ); var amount = await Context . Parameters . GetAsync < int >( 1 ); await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } After that, we need to describe how users can use the command. Add the syntax metadata to the command class: //... [CommandSyntax(\"<player> [amount] \")] // Describe the syntax/usage. Use <> for required arguments and [] for optional arguments. public class CommandAwesome : Command //...","title":"Parameters"},{"location":"development-guide/commands/#restricting-command-actors","text":"If you are not developing universal plugins, you may want to limit who can execute commands. The [CommandActor(Type)] attribute allows you to specify such restrictions. For example, if you would like to restrict a command's usage to UnturnedUser and ConsoleActor, you could add the following: //... [CommandActor(typeof(UnturnedUser))] [CommandActor(typeof(ConsoleActor))] public class CommandAwesome : Command //...","title":"Restricting Command Actors"},{"location":"development-guide/commands/#exceptions","text":"Exceptions derived from UserFriendlyException are automatically caught by OpenMod and displayed to the user in a user-friendly way. These built-in exceptions available: NotEnoughPermissionException, can be thrown if the user does not have enough permission to execute an action. CommandWrongUsageException, can be thrown on wrong command usage. Displays correct usage based on command syntax. CommandIndexOutOfRangeException, thrown automatically by Parameters.Get if the given index is bigger than the arguments length. CommandParameterParseException, thrown automatically by Parameters.Get if the parameter could not be parsed to the expected type. CommandNotFoundException, thrown automatically if a command was not found. public async Task OnExecuteAsync () { var player = await Context . Parameters . GetAsync < string >( 0 ); var amount = await Context . Parameters . GetAsync < int >( 1 ); if ( amount < 1 ) { throw new UserFriendlyException ( \"Amount cannot be negative!\" ); } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); }","title":"Exceptions"},{"location":"development-guide/commands/#command-permissions","text":"By design and for consistency reasons, you cannot define a command permission manually. OpenMod will automatically assign a permission to the command instead. You can use the help <yourcommand> command to figure out what the base permission for your command is. Assume you want to restrict the awesome command if the amount is more than 10. This is how you would do it: public async Task OnExecuteAsync () { var player = await Context . Parameters . GetAsync < string >( 0 ); var amount = await Context . Parameters . GetAsync < int >( 1 ); if ( amount > 10 && await CheckPermissionAsync ( \"MoreThan10\" ) != PermissionGrantResult . Grant ) { throw new NotEnoughPermissionException ( this , \"MoreThan10\" ); // displays an error message to the user } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); }","title":"Command Permissions"},{"location":"development-guide/commands/#adding-subcommands","text":"You can add subcommands to a command by using the [CommandParent] attribute. This allows OpenMod to discover your subcommands and provide additional help and tab autocompletion. The following command will execute when a user types \"/awesome more\". The CommandAwesome.OnExecuteAsync method will not execute in this case. [Command(\"more\")] [CommandDescription(\"My more awesome command\")] [CommandParent(typeof(CommandAwesome))] // set \"awesome\" as parent. public class CommandAwesomeMore : Command { public CommandAwesomeMore ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { // Note: Parameters do not include \"more\". // If you type \"/awesome more a\", Context.Parameters[0] will be equal to \"a\". await PrintAsync ( \"You are even more awesome!\" ); } }","title":"Adding Subcommands"},{"location":"development-guide/commands/#best-practices","text":"Do not handle sub commands yourself (e.g. if(Context.Parameters[0] == \"add\") ). OpenMod cannot discover your subcommands and provide additional help or tab completion in that case. Do not hardcode messages. Instead, use translations so users can customize and translate your messages. When writing commands, keep in mind that any type of user could execute your command by default. Maybe a plugin adds a DiscordUser and someone from Discord executes your command. Try to write your commands in a way that works with all kinds of users or restrict the allowed actors as mentioned earlier. Do not manually check if an actor is allowed to execute a command (e.g. if(!(actor is UnturnedUser)) ). Always use [CommandActor(Type)] for such restrictions. It will automatically hide the command from actors who cannot execute them and give a consistent error message.","title":"Best Practices"},{"location":"development-guide/configuration/","text":"Configurations \u00b6 Configurations allow users to configure and customize your plugin's behavior. Assume your plugin gives XP when killing a player. By using configs, a user can dynamically set how much XP will be given. OpenMod configurations are based on Microsoft.Extensions.Configuration , which are also used in ASP.NET Core. Note The \\<RootNamespace> and \\<AssemblyName> properties in the plugin's .csproj file must be equal, otherwise the IConfiguration service will not work. Adding the config.yaml \u00b6 Create a new file called \"config.yaml\" inside your project's root directory. After that, add the following to your .csproj file: <ItemGroup> <EmbeddedResource Include= \"config.yaml\" /> </ItemGroup> Reading from the configuration file \u00b6 You can use the IConfiguration service to read the config.yaml file. You can inject it like this: public class MyPlugin : OpenModUniversalPlugin { private readonly IConfiguration m_Configuration ; public MyPlugin ( IConfiguration configuration , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_Configuration = configuration ; } public async Task OnLoadAsync () { // ... } } Assume your configuration looks like this: plugin_load_delay : 500 Then this is how you would read the value: public async Task OnLoadAsync () { var delay = m_Configuration . GetSection ( \"plugin_load_delay\" ). Get < int >(); await Task . Delay ( delay ); } You can also have nested values: plugin_load : actions : wait_delay : 500 public async Task OnLoadAsync () { // notice how \":\" is used to access nested values var delay = m_Configuration . GetSection ( \"plugin_load:actions:wait_delay\" ). Get < int >(); await Task . Delay ( delay ); } If you want to access strings, you can also use the indexer: players : owner : \"Trojaner\" public async Task OnLoadAsync () { // reading strings is even easier string owner = m_Configuration [ \"players:owner\" ]; } Note Configurations are not meant to act as a storage for data, that's why there is no save method. Use Data Stores if you have read from and write data to a file. Converting configuration to C# class \u00b6 public async Task OnLoadAsync () { MyConfigClass config = m_Configuration . Get < MyConfigClass >(); // or if you only want a subset: // MyClass config = m_Configuration.GetSection(\"something\").Get<MyClass>(); } Adding your own configuration sources \u00b6 You can add additional configuration sources by implementing the IConfigurationConfigurator interface. This interface allows you to add additional sources to the IConfigurationBuilder used when building the OpenMod config. Note Custom configuration sources for plugins are not supported yet . Best Practices \u00b6 Do not hardcode important values. For example, if you are making a plugin that gives players XP when killing other players, make sure the XP amount is configurable, as it is likely something a user would want to adjust. Do not overcomplicate your configurations. Only add values that users are likely going to change. Have a simple configuration is preferred to a complex one. Do not use configurations to store messages. Use translations instead. Unlike translations, configurations do not support any kind of formatting or passing arguments.","title":"Configuration"},{"location":"development-guide/configuration/#configurations","text":"Configurations allow users to configure and customize your plugin's behavior. Assume your plugin gives XP when killing a player. By using configs, a user can dynamically set how much XP will be given. OpenMod configurations are based on Microsoft.Extensions.Configuration , which are also used in ASP.NET Core. Note The \\<RootNamespace> and \\<AssemblyName> properties in the plugin's .csproj file must be equal, otherwise the IConfiguration service will not work.","title":"Configurations"},{"location":"development-guide/configuration/#adding-the-configyaml","text":"Create a new file called \"config.yaml\" inside your project's root directory. After that, add the following to your .csproj file: <ItemGroup> <EmbeddedResource Include= \"config.yaml\" /> </ItemGroup>","title":"Adding the config.yaml"},{"location":"development-guide/configuration/#reading-from-the-configuration-file","text":"You can use the IConfiguration service to read the config.yaml file. You can inject it like this: public class MyPlugin : OpenModUniversalPlugin { private readonly IConfiguration m_Configuration ; public MyPlugin ( IConfiguration configuration , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_Configuration = configuration ; } public async Task OnLoadAsync () { // ... } } Assume your configuration looks like this: plugin_load_delay : 500 Then this is how you would read the value: public async Task OnLoadAsync () { var delay = m_Configuration . GetSection ( \"plugin_load_delay\" ). Get < int >(); await Task . Delay ( delay ); } You can also have nested values: plugin_load : actions : wait_delay : 500 public async Task OnLoadAsync () { // notice how \":\" is used to access nested values var delay = m_Configuration . GetSection ( \"plugin_load:actions:wait_delay\" ). Get < int >(); await Task . Delay ( delay ); } If you want to access strings, you can also use the indexer: players : owner : \"Trojaner\" public async Task OnLoadAsync () { // reading strings is even easier string owner = m_Configuration [ \"players:owner\" ]; } Note Configurations are not meant to act as a storage for data, that's why there is no save method. Use Data Stores if you have read from and write data to a file.","title":"Reading from the configuration file"},{"location":"development-guide/configuration/#converting-configuration-to-c-class","text":"public async Task OnLoadAsync () { MyConfigClass config = m_Configuration . Get < MyConfigClass >(); // or if you only want a subset: // MyClass config = m_Configuration.GetSection(\"something\").Get<MyClass>(); }","title":"Converting configuration to C# class"},{"location":"development-guide/configuration/#adding-your-own-configuration-sources","text":"You can add additional configuration sources by implementing the IConfigurationConfigurator interface. This interface allows you to add additional sources to the IConfigurationBuilder used when building the OpenMod config. Note Custom configuration sources for plugins are not supported yet .","title":"Adding your own configuration sources"},{"location":"development-guide/configuration/#best-practices","text":"Do not hardcode important values. For example, if you are making a plugin that gives players XP when killing other players, make sure the XP amount is configurable, as it is likely something a user would want to adjust. Do not overcomplicate your configurations. Only add values that users are likely going to change. Have a simple configuration is preferred to a complex one. Do not use configurations to store messages. Use translations instead. Unlike translations, configurations do not support any kind of formatting or passing arguments.","title":"Best Practices"},{"location":"development-guide/datastore/","text":"Data Store \u00b6 The IDataStore service provides a way of saving and loading persistent data. The default data store uses yaml files for serialization. Example \u00b6 Assume you want to save and load the following class: [Serializable] public class PlayersData { public List < string > OwnerNames { get ; set ; } } public class MyPlugin : OpenModUniversalPlugin { // Defines the key for the data. The default data store uses the key as the file name for the yaml file. // In this case, the file will be named owners.data.yaml public const string OwnersKey = \"owners\" ; private readonly IDataStore m_DataStore ; public MyPlugin ( IDataStore dataStore , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_DataStore = dataStore ; } public async Task OnLoadAsync () { // first check if the data exists and create it if it does not exist if (! await m_DataStore . ExistsAsync ( OwnersKey )) { await SeedData (); } var data = await m_DataStore . LoadAsync < PlayersData >( OwnersKey ); // do something with data await m_DataStore . SaveAsync < PlayersData >( OwnersKey , data ); } private async Task SeedData () { // create default data await m_DataStore . SaveAsync ( OwnersKey , new PlayersData { OwnerNames = new List < string > { \"Trojaner\" } }); } } Implementing your own data store \u00b6 You can replace OpenMods default yaml data store by implementing the IDataStoreFactory interface and adding the [ServiceImplementation] attribute to the concrete class.","title":"Data Store"},{"location":"development-guide/datastore/#data-store","text":"The IDataStore service provides a way of saving and loading persistent data. The default data store uses yaml files for serialization.","title":"Data Store"},{"location":"development-guide/datastore/#example","text":"Assume you want to save and load the following class: [Serializable] public class PlayersData { public List < string > OwnerNames { get ; set ; } } public class MyPlugin : OpenModUniversalPlugin { // Defines the key for the data. The default data store uses the key as the file name for the yaml file. // In this case, the file will be named owners.data.yaml public const string OwnersKey = \"owners\" ; private readonly IDataStore m_DataStore ; public MyPlugin ( IDataStore dataStore , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_DataStore = dataStore ; } public async Task OnLoadAsync () { // first check if the data exists and create it if it does not exist if (! await m_DataStore . ExistsAsync ( OwnersKey )) { await SeedData (); } var data = await m_DataStore . LoadAsync < PlayersData >( OwnersKey ); // do something with data await m_DataStore . SaveAsync < PlayersData >( OwnersKey , data ); } private async Task SeedData () { // create default data await m_DataStore . SaveAsync ( OwnersKey , new PlayersData { OwnerNames = new List < string > { \"Trojaner\" } }); } }","title":"Example"},{"location":"development-guide/datastore/#implementing-your-own-data-store","text":"You can replace OpenMods default yaml data store by implementing the IDataStoreFactory interface and adding the [ServiceImplementation] attribute to the concrete class.","title":"Implementing your own data store"},{"location":"development-guide/localization/","text":"Localization \u00b6 Localization allows users to customize and translate your plugin's messages. This is achieved through the translations.yaml file and the IStringLocalizer service. Note The \\<RootNamespace> and \\<AssemblyName> properties in the plugin's .csproj file must be equal, otherwise the IStringLocalizer service will not work. Adding the translations.yaml \u00b6 Create a new file called \"translations.yaml\" inside your project's root directory. After that, add the following to your .csproj file: <ItemGroup> <EmbeddedResource Include= \"translations.yaml\" /> </ItemGroup> Note If you used one of the templates to create your plugin project, the translations.yaml file will be already set up. Using IStringLocalizer for localization \u00b6 Assume you want to localize the following command: [Command(\"awesome\")] public class AwesomeCommand : Command { public AwesomeCommand ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { var amount = Context . Parameters . Get < int >( 0 ); await PrintAsync ( $ \"{Actor.DisplayName} is {amount}x awesome!\" ); } } First, adjust the command to use the IStringLocalizer service: [Command(\"awesome\")] public class AwesomeCommand : Command { private readonly IStringLocalizer m_StringLocalizer ; public AwesomeCommand ( IStringLocalizer stringLocalizer , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_StringLocalizer = stringLocalizer ; } public async Task OnExecuteAsync () { var count = Context . Parameters . Get < int >( 0 ); await PrintAsync ( m_StringLocalizer [ \"commands:awesome\" , new { Actor = Actor , Amount = amount }]); } } commands:awesome defines the key for the translation. The default IStringLocalizer uses the key for the path inside the yaml file. You can use any valid path, such as messages:awesome , just awesome , etc. new { Actor = Actor, Amount = amount } sets the arguments for the translations. Finally add the translation to the translations.yaml : commands : awesome : \"{Actor.DisplayName} is {Amount}x awesome!\" Notice how we can access the properties of the Actor parameter by calling Actor.DisplayName . The default IStringLocalizer uses SmartFormat.NET for parsing arguments. See the SmartFormat.NET wiki for more information.","title":"Localization"},{"location":"development-guide/localization/#localization","text":"Localization allows users to customize and translate your plugin's messages. This is achieved through the translations.yaml file and the IStringLocalizer service. Note The \\<RootNamespace> and \\<AssemblyName> properties in the plugin's .csproj file must be equal, otherwise the IStringLocalizer service will not work.","title":"Localization"},{"location":"development-guide/localization/#adding-the-translationsyaml","text":"Create a new file called \"translations.yaml\" inside your project's root directory. After that, add the following to your .csproj file: <ItemGroup> <EmbeddedResource Include= \"translations.yaml\" /> </ItemGroup> Note If you used one of the templates to create your plugin project, the translations.yaml file will be already set up.","title":"Adding the translations.yaml"},{"location":"development-guide/localization/#using-istringlocalizer-for-localization","text":"Assume you want to localize the following command: [Command(\"awesome\")] public class AwesomeCommand : Command { public AwesomeCommand ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { var amount = Context . Parameters . Get < int >( 0 ); await PrintAsync ( $ \"{Actor.DisplayName} is {amount}x awesome!\" ); } } First, adjust the command to use the IStringLocalizer service: [Command(\"awesome\")] public class AwesomeCommand : Command { private readonly IStringLocalizer m_StringLocalizer ; public AwesomeCommand ( IStringLocalizer stringLocalizer , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_StringLocalizer = stringLocalizer ; } public async Task OnExecuteAsync () { var count = Context . Parameters . Get < int >( 0 ); await PrintAsync ( m_StringLocalizer [ \"commands:awesome\" , new { Actor = Actor , Amount = amount }]); } } commands:awesome defines the key for the translation. The default IStringLocalizer uses the key for the path inside the yaml file. You can use any valid path, such as messages:awesome , just awesome , etc. new { Actor = Actor, Amount = amount } sets the arguments for the translations. Finally add the translation to the translations.yaml : commands : awesome : \"{Actor.DisplayName} is {Amount}x awesome!\" Notice how we can access the properties of the Actor parameter by calling Actor.DisplayName . The default IStringLocalizer uses SmartFormat.NET for parsing arguments. See the SmartFormat.NET wiki for more information.","title":"Using IStringLocalizer for localization"},{"location":"development-guide/logging/","text":"Logging \u00b6 OpenMod uses the Microsoft.Extensions.Logging package for logging abstractions and Serilog as the logging implementation for it. For more, check out the ILogger Interface documentation on docs.microsoft.com . You can get a logger instance by injecting it via dependency injection: public class MyPlugin : OpenModUniversalPlugin { private readonly ILogger < MyPlugin > m_Logger ; public MyPlugin ( ILogger < MyPlugin > logger , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_Logger = logger ; m_Logger . LogInformation ( \"Hello world!\" ); } } The generic part ( XX in ILogger<XX> ) must be the class that is using the logger. Implementing your own logger \u00b6 To implement your own logger, you must implement the ILoggerFactory , ILogger , and ILogger<> services. After that you must register them via a ServiceConfigurator : public class ServiceConfigurator : IServiceConfigurator { public void ConfigureServices ( IOpenModStartupContext openModStartupContext , IServiceCollection serviceCollection ) { serviceCollection . AddSingleton < ILoggerFactory , MyLoggerFactory >(); serviceCollection . AddTransient < ILogger , MyLogger >(); // must be transient serviceCollection . AddTransient ( typeof ( ILogger <>), typeof ( MyLogger <>)(); // must be transient } } Note Your custom logger will not be used while OpenMod is booting and creating the IoC container. It will be used once OpenMod has fully started. Best Practices \u00b6 Do not inject the ILogger interface directly. This will prevent the logger from associating your log messages with your class. A user can also not configure minimum log levels or other options for your log messages in that case.","title":"Logging"},{"location":"development-guide/logging/#logging","text":"OpenMod uses the Microsoft.Extensions.Logging package for logging abstractions and Serilog as the logging implementation for it. For more, check out the ILogger Interface documentation on docs.microsoft.com . You can get a logger instance by injecting it via dependency injection: public class MyPlugin : OpenModUniversalPlugin { private readonly ILogger < MyPlugin > m_Logger ; public MyPlugin ( ILogger < MyPlugin > logger , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_Logger = logger ; m_Logger . LogInformation ( \"Hello world!\" ); } } The generic part ( XX in ILogger<XX> ) must be the class that is using the logger.","title":"Logging"},{"location":"development-guide/logging/#implementing-your-own-logger","text":"To implement your own logger, you must implement the ILoggerFactory , ILogger , and ILogger<> services. After that you must register them via a ServiceConfigurator : public class ServiceConfigurator : IServiceConfigurator { public void ConfigureServices ( IOpenModStartupContext openModStartupContext , IServiceCollection serviceCollection ) { serviceCollection . AddSingleton < ILoggerFactory , MyLoggerFactory >(); serviceCollection . AddTransient < ILogger , MyLogger >(); // must be transient serviceCollection . AddTransient ( typeof ( ILogger <>), typeof ( MyLogger <>)(); // must be transient } } Note Your custom logger will not be used while OpenMod is booting and creating the IoC container. It will be used once OpenMod has fully started.","title":"Implementing your own logger"},{"location":"development-guide/logging/#best-practices","text":"Do not inject the ILogger interface directly. This will prevent the logger from associating your log messages with your class. A user can also not configure minimum log levels or other options for your log messages in that case.","title":"Best Practices"},{"location":"development-guide/making-your-first-plugin/","text":"Making your first plugin \u00b6 In this guide we will cover: Setting up a development environment. Creating a plugin project. Writing a basic plugin. Installing the .NET Core SDK \u00b6 Install the latest .NET Core SDK from here (you should get a dotnet-sdk-xxxxx.zip ). Installing the IDE \u00b6 After setting up the .NET Core SDK, you will have to install an IDE. The IDE provides you an environment where you can code your plugins. Visual Studio Code (preferred) \u00b6 You can use Visual Studio Code for developing OpenMod plugins. It supports Linux, macOS, and Windows. Visual Studio Code is the preferred solution for small to mid-sized projects. Visual Studio \u00b6 If you want a full IDE experience, download and install Visual Studio Community Edition . Visual Studio is only supported on the Windows platform. When the installer starts, select \"Visual Studio 2019 Community Edition\" (or newer, if available). After that select the \".NET Core cross-platform development\" and the \".NET Desktop Development\" options as shown below. Rider \u00b6 If you are using Linux and do not want to use Visual Studio Code, you can install Rider . Although it is a commercial product, it can be obtained for free when applying for a Jetbrains Student License. Like Visual Studio, it provides a full IDE experience and has similar capabilities. Generating the Plugin Project \u00b6 Start cmd or Powershell and navigate to the folder where you want to create the plugin project. E.g. mkdir C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ cd C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ After that, install the OpenMod Plugin Templates for the .NET Core SDK: dotnet new -i \"OpenMod.Templates::*\" Finally, you can generate the plugin project with this command: dotnet new openmod-universal-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] or, if you want to develop a plugin for Unturned: dotnet new openmod-unturned-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] PluginId must be a unique identifier for your plugin. By convention, it is the same as the NuGet package ID. FullPluginName is optional and will set how your plugin should be displayed to the user. To get the full help for the command, you can use the --help switch like this: dotnet new openmod-universal-plugin --help or, for Unturned: dotnet new openmod-unturned-plugin --help Example \u00b6 If you want to create an Unturned plugin project, you can use the following command: dotnet new openmod-unturned-plugin --FullPluginName \"My Unturned Plugin\" --PluginId \"MyName.MyUnturnedPlugin\" Adding a Basic Command \u00b6 Now that you've set up your plugin, open the .csproj file with the IDE you have installed earlier. In this example we are creating an echo command. Create a new class (how you do this depends on your IDE). By convention command classes are prefixed with \"Command\" so call it CommandEcho. Since this will be an universal command that works on all platforms, we will make it inherit from Command . If this command would be only for Unturned, we would inherit from UnturnedCommand instead. This is what your class should look like: public class CommandEcho : Command { } Let's go ahead and fix the error by implementing the method ExecuteAsync() and a constructor. For now, do not worry about what async is. This is going to be the method that executes what you want your command to perform. So now, you will be wanting to know how you can access the in-game data and methods. You can access the command context without the parameters, by simply using Context (this comes from using the Command abstract class). This will allow you to access the Player, from now it is quite easy, let's see a finished product of this command. [Command(\"echo\")] [CommandDescription(\"Echo a message\")] [CommandSyntax(\"<message>\")] public class CommandEcho : Command { public CommandEcho ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } protected override async Task OnExecuteAsync () { // This gets us the text that the user wants to echo. string text = string . Join ( \" \" , Context . Parameters ); await Context . Actor . PrintMessageAsync ( text ); } } OnExecuteAsync is getting called by the command executor and provides you with the commands \"context\". At the top of the class, you will see we are setting our command metadata using attributes. For more, visit the commands documentation . Best Practices \u00b6 Do not use static plugin instances, instead always pass instances by reference. OpenMod dynamically creates and destroys your plugin instances, which would result in wrong instances being used after reloads.","title":"Making your first plugin"},{"location":"development-guide/making-your-first-plugin/#making-your-first-plugin","text":"In this guide we will cover: Setting up a development environment. Creating a plugin project. Writing a basic plugin.","title":"Making your first plugin"},{"location":"development-guide/making-your-first-plugin/#installing-the-net-core-sdk","text":"Install the latest .NET Core SDK from here (you should get a dotnet-sdk-xxxxx.zip ).","title":"Installing the .NET Core SDK"},{"location":"development-guide/making-your-first-plugin/#installing-the-ide","text":"After setting up the .NET Core SDK, you will have to install an IDE. The IDE provides you an environment where you can code your plugins.","title":"Installing the IDE"},{"location":"development-guide/making-your-first-plugin/#visual-studio-code-preferred","text":"You can use Visual Studio Code for developing OpenMod plugins. It supports Linux, macOS, and Windows. Visual Studio Code is the preferred solution for small to mid-sized projects.","title":"Visual Studio Code (preferred)"},{"location":"development-guide/making-your-first-plugin/#visual-studio","text":"If you want a full IDE experience, download and install Visual Studio Community Edition . Visual Studio is only supported on the Windows platform. When the installer starts, select \"Visual Studio 2019 Community Edition\" (or newer, if available). After that select the \".NET Core cross-platform development\" and the \".NET Desktop Development\" options as shown below.","title":"Visual Studio"},{"location":"development-guide/making-your-first-plugin/#rider","text":"If you are using Linux and do not want to use Visual Studio Code, you can install Rider . Although it is a commercial product, it can be obtained for free when applying for a Jetbrains Student License. Like Visual Studio, it provides a full IDE experience and has similar capabilities.","title":"Rider"},{"location":"development-guide/making-your-first-plugin/#generating-the-plugin-project","text":"Start cmd or Powershell and navigate to the folder where you want to create the plugin project. E.g. mkdir C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ cd C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ After that, install the OpenMod Plugin Templates for the .NET Core SDK: dotnet new -i \"OpenMod.Templates::*\" Finally, you can generate the plugin project with this command: dotnet new openmod-universal-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] or, if you want to develop a plugin for Unturned: dotnet new openmod-unturned-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] PluginId must be a unique identifier for your plugin. By convention, it is the same as the NuGet package ID. FullPluginName is optional and will set how your plugin should be displayed to the user. To get the full help for the command, you can use the --help switch like this: dotnet new openmod-universal-plugin --help or, for Unturned: dotnet new openmod-unturned-plugin --help","title":"Generating the Plugin Project"},{"location":"development-guide/making-your-first-plugin/#example","text":"If you want to create an Unturned plugin project, you can use the following command: dotnet new openmod-unturned-plugin --FullPluginName \"My Unturned Plugin\" --PluginId \"MyName.MyUnturnedPlugin\"","title":"Example"},{"location":"development-guide/making-your-first-plugin/#adding-a-basic-command","text":"Now that you've set up your plugin, open the .csproj file with the IDE you have installed earlier. In this example we are creating an echo command. Create a new class (how you do this depends on your IDE). By convention command classes are prefixed with \"Command\" so call it CommandEcho. Since this will be an universal command that works on all platforms, we will make it inherit from Command . If this command would be only for Unturned, we would inherit from UnturnedCommand instead. This is what your class should look like: public class CommandEcho : Command { } Let's go ahead and fix the error by implementing the method ExecuteAsync() and a constructor. For now, do not worry about what async is. This is going to be the method that executes what you want your command to perform. So now, you will be wanting to know how you can access the in-game data and methods. You can access the command context without the parameters, by simply using Context (this comes from using the Command abstract class). This will allow you to access the Player, from now it is quite easy, let's see a finished product of this command. [Command(\"echo\")] [CommandDescription(\"Echo a message\")] [CommandSyntax(\"<message>\")] public class CommandEcho : Command { public CommandEcho ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } protected override async Task OnExecuteAsync () { // This gets us the text that the user wants to echo. string text = string . Join ( \" \" , Context . Parameters ); await Context . Actor . PrintMessageAsync ( text ); } } OnExecuteAsync is getting called by the command executor and provides you with the commands \"context\". At the top of the class, you will see we are setting our command metadata using attributes. For more, visit the commands documentation .","title":"Adding a Basic Command"},{"location":"development-guide/making-your-first-plugin/#best-practices","text":"Do not use static plugin instances, instead always pass instances by reference. OpenMod dynamically creates and destroys your plugin instances, which would result in wrong instances being used after reloads.","title":"Best Practices"},{"location":"development-guide/permissions/","text":"Permissions \u00b6 Permissions allow defining which actions a user is permitted to execute and which he is not. You can use the IPermissionChecker service to check if a user has specific permissions: // read event documentation for more information about event listeners public class UserConnectBroadcaster : IEventListener < UserConnectedEvent > { private readonly IPermissionChecker m_PermissionChecker ; private readonly IUserManager m_UserManager ; public UserConnectEventListener ( IPermissionChecker permissionChecker , IUserManager userManager ) { m_PermissionChecker = permissionChecker ; m_UserManager = userManager ; } public async Task HandleEventAsync ( object sender , UserConnectedEvent @event ) { var user = @event . User ; if ( m_PermissionChecker . CheckPermissionAsync ( user , \"announce.join\" ) == PermissionGrantResult . Grant ) { await m_UserManager . BroadcastAsync ( user . Type , $ \"{user.DisplayName} has joined.\" ); } } } Let's have a closer look at CheckPermissionAsync . CheckPermissionAsync returns PermissionGrantResult , which is an enum with members: Default - The permission is neither explicitly granted nor explicitly denied Grant - The permission was explicitly granted Deny - The permission was explicitly denied Usually, you want to check if the result equals to PermissionGrantResult.Grant to permit an action. This means that if no explicit permission is set, the action will be denied by default. If you want to execute an action unless it is explicitly denied, use CheckPermissionAsync(..) != PermissionGrantResult.Deny . Adding your own permissions \u00b6 You can add your own permissions (e.g. to store permissions in MySQL): Implement IPermissionStore Add your IPermissionStore via a ServiceConfigurator : public class ServiceConfigurator : IServiceConfigurator { public void ConfigureServices ( IOpenModStartupContext openModStartupContext , IServiceCollection serviceCollection ) { serviceCollection . Configure < PermissionCheckerOptions >( options => { options . AddPermissionSource < YourPermissionStore >(); }); } } Override permission checks \u00b6 Sometimes you may want to check yourself if an actor has a permission. Implement IPermissionCheckSource Add your IPermissionCheckSource via a ServiceConfigurator : public class ServiceConfigurator : IServiceConfigurator { public void ConfigureServices ( IOpenModStartupContext openModStartupContext , IServiceCollection serviceCollection ) { serviceCollection . Configure < PermissionCheckerOptions >( options => { options . AddPermissionCheckSource < YourPermissionCheckSource >(); }); } } The following example will grant all permissions to Unturned admins: public class UnturnedAdminPermissionCheckProvider : IPermissionCheckProvider { public bool SupportsActor ( IPermissionActor actor ) { /* only apply to unturned admins */ return actor is UnturnedUser user && user . SteamPlayer . isAdmin ; } public Task < PermissionGrantResult > CheckPermissionAsync ( IPermissionActor actor , string permission ) { /* grant on any permission */ return Task . FromResult ( PermissionGrantResult . Grant ); } }","title":"Permissions"},{"location":"development-guide/permissions/#permissions","text":"Permissions allow defining which actions a user is permitted to execute and which he is not. You can use the IPermissionChecker service to check if a user has specific permissions: // read event documentation for more information about event listeners public class UserConnectBroadcaster : IEventListener < UserConnectedEvent > { private readonly IPermissionChecker m_PermissionChecker ; private readonly IUserManager m_UserManager ; public UserConnectEventListener ( IPermissionChecker permissionChecker , IUserManager userManager ) { m_PermissionChecker = permissionChecker ; m_UserManager = userManager ; } public async Task HandleEventAsync ( object sender , UserConnectedEvent @event ) { var user = @event . User ; if ( m_PermissionChecker . CheckPermissionAsync ( user , \"announce.join\" ) == PermissionGrantResult . Grant ) { await m_UserManager . BroadcastAsync ( user . Type , $ \"{user.DisplayName} has joined.\" ); } } } Let's have a closer look at CheckPermissionAsync . CheckPermissionAsync returns PermissionGrantResult , which is an enum with members: Default - The permission is neither explicitly granted nor explicitly denied Grant - The permission was explicitly granted Deny - The permission was explicitly denied Usually, you want to check if the result equals to PermissionGrantResult.Grant to permit an action. This means that if no explicit permission is set, the action will be denied by default. If you want to execute an action unless it is explicitly denied, use CheckPermissionAsync(..) != PermissionGrantResult.Deny .","title":"Permissions"},{"location":"development-guide/permissions/#adding-your-own-permissions","text":"You can add your own permissions (e.g. to store permissions in MySQL): Implement IPermissionStore Add your IPermissionStore via a ServiceConfigurator : public class ServiceConfigurator : IServiceConfigurator { public void ConfigureServices ( IOpenModStartupContext openModStartupContext , IServiceCollection serviceCollection ) { serviceCollection . Configure < PermissionCheckerOptions >( options => { options . AddPermissionSource < YourPermissionStore >(); }); } }","title":"Adding your own permissions"},{"location":"development-guide/permissions/#override-permission-checks","text":"Sometimes you may want to check yourself if an actor has a permission. Implement IPermissionCheckSource Add your IPermissionCheckSource via a ServiceConfigurator : public class ServiceConfigurator : IServiceConfigurator { public void ConfigureServices ( IOpenModStartupContext openModStartupContext , IServiceCollection serviceCollection ) { serviceCollection . Configure < PermissionCheckerOptions >( options => { options . AddPermissionCheckSource < YourPermissionCheckSource >(); }); } } The following example will grant all permissions to Unturned admins: public class UnturnedAdminPermissionCheckProvider : IPermissionCheckProvider { public bool SupportsActor ( IPermissionActor actor ) { /* only apply to unturned admins */ return actor is UnturnedUser user && user . SteamPlayer . isAdmin ; } public Task < PermissionGrantResult > CheckPermissionAsync ( IPermissionActor actor , string permission ) { /* grant on any permission */ return Task . FromResult ( PermissionGrantResult . Grant ); } }","title":"Override permission checks"},{"location":"development-guide/publishing-to-nuget/","text":"Publishing to nuget.org \u00b6 If you want your plugin to be installable from openmod install , you will need to publish it to nuget.org. You will need a Microsoft account for nuget.org . Preparing your plugin for NuGet \u00b6 Add the following to your plugin's .csproj <PropertyGroup> <PackageId> Your PackageId </PackageId> <!-- must be unique, should be same as your plugin ID --> <PackageDescription> Your plugin description </PackageDescription> <PackageLicenseExpression> Your License </PackageLicenseExpression> <!-- see https://spdx.org/licenses/ --> <PackageAuthor> Your name </PackageAuthor> <PackageTags> openmod openmod-plugin XXX </PackageTags> <!-- XXX can be unturned, unityengine or universal depending on your plugin --> <Version> x.x.x </Version> <!-- Your plugins version. Must be semversion, see https://semver.org/ --> <AssemblyVersion> x.x.x </AssemblyVersion> <!-- set same as package version, required for dynamicalliy updating your plugin --> <GeneratePackageOnBuild> true </GeneratePackageOnBuild> <GenerateNugetPackage> true </GenerateNugetPackage> </PropertyGroup> Sign in to nuget.org . Click on your username, select API Keys. Select create. Add a name, select the Push scope and add * as Glob pattern, then select create. Copy your newly created key. Save your key securely as you cannot retrieve it again. Uploading the plugin \u00b6 Navigate to your plugin's folder. Execute the following command: dotnet build --configuration Release . Go to bin/Release/ and push to NuGet: dotnet push <yourpackageid.x.x.x.nupkg> -n -k <your nuget.org key> -s https://api.nuget.org/v3/index.json You can install your plugin with openmod install <YourPackageId> . Note You may get the \"PackageOrVersionNotFound\" error after trying to install your plugin. This means your upload has not been verified or indexed yet. It may take up to an hour until uploads to nuget.org are verified and indexed. For more, read the Publishing packages and Create and publish a NuGet package (dotnet CLI) pages on docs.microsoft.com. Plugin Versioning with Semantic Versioning \u00b6 Like OpenMod, NuGet also uses Semantic Versioning 2.0.0. Here is a short summary on how versioning works: Semantic Versioning follow the following template: Major.Minor.Patch . First Major is compared, then Minor and finally Patch. So 3.0.1 > 2.1.5 > 1.45.8 > 0.999.0 . Your plugin starts with version 0.1.0 and increments tee \"Minor\" version as it progresses towards release (e.g. 0.2.0 ). When your plugin is ready for release, version 1.0.0 is used. For bug fixes, increase the \"Patch\" version (e.g. 1.0.1 ). For new feature additions, increase the \"Minor\" version (e.g. 1.1.0 ). For breaking changes (e.g. public API changes or breaking configs, etc.), increment the Major version (e.g. 2.0.0 ). You can also use -rc1, -beta, -alpha, -beta2 etc. suffixes to indicate a pre release version (e.g. 2.0.0-rc1 ) In this case version comparison is done alphabetically, e.g. 1.0.0-rc2 is \"newer\" than 1.0.0-rc1 and 1.0.0-beta , but 1.0.0 is the newest because it is not a pre release version. You can attach any arbitary information, such as the commit hash, by using the + suffix (e.g. 1.0.0+525ffaa or 1.0.0-rc1+525ffaa ). Everything after the + is ignored and not used for version comparison. The following are valid semantic version examples: 0.0.1 1.0.9 1.45.6 1.0.0-alpha 1.0.0-beta1 1.3.5-rc1 1.3.5-rc2+somearbitaryinformation The following are invalid semantic versions: 1.0.0.0 v1.0.0 For a full reference, please read the semantic versioning website . Publish with a GitHub workflow \u00b6 You can use GitHub workflows to publish to NuGet with one click. Create the following file in your repository's .github/workflow folder. The following assumes that your plugins source code is in the YOURPLUGIN folder under your repositories root directory. name : Deployment on : workflow_dispatch : inputs : version : description : 'Plugin Version (SemVer: https://semver.org)' required : true jobs : deploy : name : \"NuGet Deployment\" runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 name : Checkout Repository with : fetch-depth : 0 - name : Setup .NET Core uses : actions/setup-dotnet@v1 with : dotnet-version : 3.1.101 - name : Install dependencies run : dotnet restore - name : Update version run : \"sed -i \\\"s#<Version>0.0.0</Version>#<Version>${{ github.event.inputs.version }}</Version>#\\\" YOURPLUGIN/YOURPLUGIN.csproj\" - name : Build run : dotnet build YOURPLUGIN/YOURPLUGIN.csproj --configuration Release --no-restore - name : Push to NuGet run : dotnet nuget push YOURPLUGIN/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_DEPLOY_KEY }} --source https://api.nuget.org/v3/index.json After that you must edit the <Version>x.x.x</Version> in your .csproj and set it to <Version>0.0.0</Version> . Finally, to finish setting up the workflow, you must add your NuGet secret: Go to https://github.com/YOURNAME/YOURPLUGIN/settings/secrets Create new secret Name it \"NUGET_DEPLOY_KEY\" and add your NuGet API Key to it To publish a new version of your plugin, all you have to do is to: Go to your repository on GitHub Click on \"Actions\" Select \"NuGet Deployment\" on the left Click on \"Run workflow\" on the right Enter plugin version and be sure to follow the versioning rules from above, then click \"Run workflow\". Check the workflow log if any error occured. Done, your plugin has been built and uploaded to nuget.org. Here is an example from the NewEssentials plugin made by Kr4ken: It takes about 10-30 minutes for your plugin to be published to nuget.org. After waiting you can use openmod install <YourPluginsPackageId> to install your plugin. Note You may get the \"PackageOrVersionNotFound\" error after trying to install your plugin. This means your upload has not been verified or indexed yet. It may take up to an hour until uploads to nuget.org are verified and indexed.","title":"Publishing to nuget.org"},{"location":"development-guide/publishing-to-nuget/#publishing-to-nugetorg","text":"If you want your plugin to be installable from openmod install , you will need to publish it to nuget.org. You will need a Microsoft account for nuget.org .","title":"Publishing to nuget.org"},{"location":"development-guide/publishing-to-nuget/#preparing-your-plugin-for-nuget","text":"Add the following to your plugin's .csproj <PropertyGroup> <PackageId> Your PackageId </PackageId> <!-- must be unique, should be same as your plugin ID --> <PackageDescription> Your plugin description </PackageDescription> <PackageLicenseExpression> Your License </PackageLicenseExpression> <!-- see https://spdx.org/licenses/ --> <PackageAuthor> Your name </PackageAuthor> <PackageTags> openmod openmod-plugin XXX </PackageTags> <!-- XXX can be unturned, unityengine or universal depending on your plugin --> <Version> x.x.x </Version> <!-- Your plugins version. Must be semversion, see https://semver.org/ --> <AssemblyVersion> x.x.x </AssemblyVersion> <!-- set same as package version, required for dynamicalliy updating your plugin --> <GeneratePackageOnBuild> true </GeneratePackageOnBuild> <GenerateNugetPackage> true </GenerateNugetPackage> </PropertyGroup> Sign in to nuget.org . Click on your username, select API Keys. Select create. Add a name, select the Push scope and add * as Glob pattern, then select create. Copy your newly created key. Save your key securely as you cannot retrieve it again.","title":"Preparing your plugin for NuGet"},{"location":"development-guide/publishing-to-nuget/#uploading-the-plugin","text":"Navigate to your plugin's folder. Execute the following command: dotnet build --configuration Release . Go to bin/Release/ and push to NuGet: dotnet push <yourpackageid.x.x.x.nupkg> -n -k <your nuget.org key> -s https://api.nuget.org/v3/index.json You can install your plugin with openmod install <YourPackageId> . Note You may get the \"PackageOrVersionNotFound\" error after trying to install your plugin. This means your upload has not been verified or indexed yet. It may take up to an hour until uploads to nuget.org are verified and indexed. For more, read the Publishing packages and Create and publish a NuGet package (dotnet CLI) pages on docs.microsoft.com.","title":"Uploading the plugin"},{"location":"development-guide/publishing-to-nuget/#plugin-versioning-with-semantic-versioning","text":"Like OpenMod, NuGet also uses Semantic Versioning 2.0.0. Here is a short summary on how versioning works: Semantic Versioning follow the following template: Major.Minor.Patch . First Major is compared, then Minor and finally Patch. So 3.0.1 > 2.1.5 > 1.45.8 > 0.999.0 . Your plugin starts with version 0.1.0 and increments tee \"Minor\" version as it progresses towards release (e.g. 0.2.0 ). When your plugin is ready for release, version 1.0.0 is used. For bug fixes, increase the \"Patch\" version (e.g. 1.0.1 ). For new feature additions, increase the \"Minor\" version (e.g. 1.1.0 ). For breaking changes (e.g. public API changes or breaking configs, etc.), increment the Major version (e.g. 2.0.0 ). You can also use -rc1, -beta, -alpha, -beta2 etc. suffixes to indicate a pre release version (e.g. 2.0.0-rc1 ) In this case version comparison is done alphabetically, e.g. 1.0.0-rc2 is \"newer\" than 1.0.0-rc1 and 1.0.0-beta , but 1.0.0 is the newest because it is not a pre release version. You can attach any arbitary information, such as the commit hash, by using the + suffix (e.g. 1.0.0+525ffaa or 1.0.0-rc1+525ffaa ). Everything after the + is ignored and not used for version comparison. The following are valid semantic version examples: 0.0.1 1.0.9 1.45.6 1.0.0-alpha 1.0.0-beta1 1.3.5-rc1 1.3.5-rc2+somearbitaryinformation The following are invalid semantic versions: 1.0.0.0 v1.0.0 For a full reference, please read the semantic versioning website .","title":"Plugin Versioning with Semantic Versioning"},{"location":"development-guide/publishing-to-nuget/#publish-with-a-github-workflow","text":"You can use GitHub workflows to publish to NuGet with one click. Create the following file in your repository's .github/workflow folder. The following assumes that your plugins source code is in the YOURPLUGIN folder under your repositories root directory. name : Deployment on : workflow_dispatch : inputs : version : description : 'Plugin Version (SemVer: https://semver.org)' required : true jobs : deploy : name : \"NuGet Deployment\" runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 name : Checkout Repository with : fetch-depth : 0 - name : Setup .NET Core uses : actions/setup-dotnet@v1 with : dotnet-version : 3.1.101 - name : Install dependencies run : dotnet restore - name : Update version run : \"sed -i \\\"s#<Version>0.0.0</Version>#<Version>${{ github.event.inputs.version }}</Version>#\\\" YOURPLUGIN/YOURPLUGIN.csproj\" - name : Build run : dotnet build YOURPLUGIN/YOURPLUGIN.csproj --configuration Release --no-restore - name : Push to NuGet run : dotnet nuget push YOURPLUGIN/bin/Release/*.nupkg --api-key ${{ secrets.NUGET_DEPLOY_KEY }} --source https://api.nuget.org/v3/index.json After that you must edit the <Version>x.x.x</Version> in your .csproj and set it to <Version>0.0.0</Version> . Finally, to finish setting up the workflow, you must add your NuGet secret: Go to https://github.com/YOURNAME/YOURPLUGIN/settings/secrets Create new secret Name it \"NUGET_DEPLOY_KEY\" and add your NuGet API Key to it To publish a new version of your plugin, all you have to do is to: Go to your repository on GitHub Click on \"Actions\" Select \"NuGet Deployment\" on the left Click on \"Run workflow\" on the right Enter plugin version and be sure to follow the versioning rules from above, then click \"Run workflow\". Check the workflow log if any error occured. Done, your plugin has been built and uploaded to nuget.org. Here is an example from the NewEssentials plugin made by Kr4ken: It takes about 10-30 minutes for your plugin to be published to nuget.org. After waiting you can use openmod install <YourPluginsPackageId> to install your plugin. Note You may get the \"PackageOrVersionNotFound\" error after trying to install your plugin. This means your upload has not been verified or indexed yet. It may take up to an hour until uploads to nuget.org are verified and indexed.","title":"Publish with a GitHub workflow"},{"location":"development-guide/scheduling/","text":"Scheduling Tasks \u00b6 OpenMod provides the AsyncHelper.Schedule method for fire-and-forget tasks. It will enqueue the given task on a thread pool. This can be used to run tasks delayed or periodically. Universal \u00b6 The following examples work on all OpenMod platforms. Running a delayed Task \u00b6 You can delay a Task like this: public async Task MyTask () { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } Then call AsyncHelper.Schedule like this: AsyncHelper . Schedule ( \"My Task\" , () => MyTask ()); Running a Task periodically \u00b6 If you want to run a Task periodically, all you have to do is to surround your task with a while loop: public async Task MyPeriodicTask ( IOpenModPlugin myPlugin ) { while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } } Then call AsyncHelper.Schedule like earlier, but passing the plugin instance: AsyncHelper . Schedule ( \"My Task\" , () => MyPeriodicTask ( myPlugin )); UnityEngine \u00b6 The following examples only work with games using the UnityEngine such as Unturned. Running a Task on every Update \u00b6 Like in the Running a Task Periodically example, we will use a while loop again. Notice how the return type has changed to UniTask and how the call to the AsyncHelper.Schedule method has changed. public async UniTask MyUpdateTask ( IOpenModPlugin myPlugin ) { await UniTask . SwitchToMainThread (); // ensure this runs on main thread first. int i = 0 ; while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { await UniTask . DelayFrame ( 1 , PlayerLoopTiming . Update ); m_Logger . LogInformation ( $ \"Frame update: {++i}\" ); } } Let's break this down. Inspect the following line: await UniTask.DelayFrame(1, PlayerLoopTiming.Update) The first parameter, the 1, defines how many frames to wait. So this example will always wait for one frame and hence runs on every frame update. The second parameter, PlayerLoopTiming.Update, sets which type of update it should wait for. In this example, it is a normal frame update. You can use other update types such as FixedUpdate too. The following update types are available: EarlyUpdate, LastEarlyUpdate, FixedUpdate, LastFixedUpdate, PreUpdate, LastPreUpdate, Update, LastUpdate, PreLateUpdate, LastPreLateUpdate, PostLateUpdate, LastPostLateUpdate To schedule your task, call the AsyncHelper like this: AsyncHelper . Schedule ( \"My Task\" , () => MyUpdateTask ( myPlugin ). AsTask () /* for UniTask, you will have to use .AsTask() */ ); Best Practices \u00b6 Do not use Thread.Sleep or similar blocking methods like non-async I/O methods in Tasks. These methods will block the thread and prevent other tasks from running. Always use the async Task methods instead, like Task.Delay . Do not keep your tasks running after your plugin gets unloaded.","title":"Scheduling"},{"location":"development-guide/scheduling/#scheduling-tasks","text":"OpenMod provides the AsyncHelper.Schedule method for fire-and-forget tasks. It will enqueue the given task on a thread pool. This can be used to run tasks delayed or periodically.","title":"Scheduling Tasks"},{"location":"development-guide/scheduling/#universal","text":"The following examples work on all OpenMod platforms.","title":"Universal"},{"location":"development-guide/scheduling/#running-a-delayed-task","text":"You can delay a Task like this: public async Task MyTask () { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } Then call AsyncHelper.Schedule like this: AsyncHelper . Schedule ( \"My Task\" , () => MyTask ());","title":"Running a delayed Task"},{"location":"development-guide/scheduling/#running-a-task-periodically","text":"If you want to run a Task periodically, all you have to do is to surround your task with a while loop: public async Task MyPeriodicTask ( IOpenModPlugin myPlugin ) { while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } } Then call AsyncHelper.Schedule like earlier, but passing the plugin instance: AsyncHelper . Schedule ( \"My Task\" , () => MyPeriodicTask ( myPlugin ));","title":"Running a Task periodically"},{"location":"development-guide/scheduling/#unityengine","text":"The following examples only work with games using the UnityEngine such as Unturned.","title":"UnityEngine"},{"location":"development-guide/scheduling/#running-a-task-on-every-update","text":"Like in the Running a Task Periodically example, we will use a while loop again. Notice how the return type has changed to UniTask and how the call to the AsyncHelper.Schedule method has changed. public async UniTask MyUpdateTask ( IOpenModPlugin myPlugin ) { await UniTask . SwitchToMainThread (); // ensure this runs on main thread first. int i = 0 ; while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { await UniTask . DelayFrame ( 1 , PlayerLoopTiming . Update ); m_Logger . LogInformation ( $ \"Frame update: {++i}\" ); } } Let's break this down. Inspect the following line: await UniTask.DelayFrame(1, PlayerLoopTiming.Update) The first parameter, the 1, defines how many frames to wait. So this example will always wait for one frame and hence runs on every frame update. The second parameter, PlayerLoopTiming.Update, sets which type of update it should wait for. In this example, it is a normal frame update. You can use other update types such as FixedUpdate too. The following update types are available: EarlyUpdate, LastEarlyUpdate, FixedUpdate, LastFixedUpdate, PreUpdate, LastPreUpdate, Update, LastUpdate, PreLateUpdate, LastPreLateUpdate, PostLateUpdate, LastPostLateUpdate To schedule your task, call the AsyncHelper like this: AsyncHelper . Schedule ( \"My Task\" , () => MyUpdateTask ( myPlugin ). AsTask () /* for UniTask, you will have to use .AsTask() */ );","title":"Running a Task on every Update"},{"location":"development-guide/scheduling/#best-practices","text":"Do not use Thread.Sleep or similar blocking methods like non-async I/O methods in Tasks. These methods will block the thread and prevent other tasks from running. Always use the async Task methods instead, like Task.Delay . Do not keep your tasks running after your plugin gets unloaded.","title":"Best Practices"},{"location":"development-guide/services/","text":"Services and dependency injection \u00b6 OpenMod, like other modern .NET projects, uses the dependency injection pattern . This guide aims to simplify it and explain what it means for plugin developers using OpenMod. Plugins, commands, event listeners, and services can automatically get references to plugins or any other services provided by OpenMod just by adding their interfaces to the constructor. See the example below. Dependency injection example \u00b6 Let's see this in action: This is how your plugin looks like normally: public class MyPlugin ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } If you wanted to access the IStringLocalizer service, you could it like this: public class MyPlugin ( IStringLocalizer stringLocalizer , IServiceProvider serviceProvider ) : base ( serviceProvider ) { // do something with stringLocalizer } Assume you want to access your plugin's instance and configuration from a command. Here is how you could do it: private readonly IConfiguration m_Configuration ; private readonly MyPlugin m_MyPlugin ; public EchoCommand ( IServiceProvider serviceProvider , MyPlugin myPlugin , IConfiguration configuration ) : base ( serviceProvider ) m_MyPlugin = myPlugin ; m_Configuration = configuration ; } Registering your own services \u00b6 There are two ways to register a service: Registering by using the [Service] attribute for the interface and [ServiceImplementation] for the concrete class. Registering manually by implementing the IServiceConfigurator or IContainerConfigurator interfaces. Classes which implement these interfaces are automatically instantiated when the IoC container is configured and can be used to configure the container directly. You can implement the IDisposable or the IAsyncDisposable interface for cleaning up resources when OpenMod reloads or shuts down. You can use the IPluginAccessor<> service, to access your plugins instance and its services. Here is an example service to clear vehicles: [Service] public interface IVehicleClearingService { Task ClearVehiclesAsync (); } [ServiceImplementation(Lifetime = ServiceLifetime.Transient)] public class VehicleClearingService : IVehicleClearingService , IAsyncDisposable { private readonly IStringLocalizer m_StringLocalizer ; private readonly ILogger < VehicleClearingService > m_Logger ; public VehicleClearingService ( ILogger < VehicleClearingService > logger , IPluginAccessor < VehicleClearerPlugin > pluginAccessor ) { VehicleClearerPlugin plugin = pluginAccessor . Instance ; // Services live in the global OpenMod scope, which does not provide an IStringLocalizer. // Since IStringLocalizer does not exist in this scope, we have to use the plugins scope. m_StringLocalizer = plugin . Lifetime . Resolve < IStringLocalizer >(); m_Logger = logger ; } public async Task ClearVehiclesAsync () { m_Logger . LogInformation ( m_StringLocalizer [ \"messages:clearing_vehicles\" ]); // translation is read from the plugins translation // call game apis to clear vehicles... } // Service dispose methods are called on OpenMod reload or server shutdown public async ValueTask DisposeAsync () { await ClearVehiclesAsync (); // ensure vehicles get cleared on reload or shutdown } } You can now access this service by injecting IVehicleClearingService in e.g. commands, event listeners, your plugin class, or other services. Note Custom services have a different lifetime than plugins. Even if your plugin unloads, your service will still be alive and used. Services are created before plugins load and are destroyed when openmod reloads or the server shuts down. Service lifetime \u00b6 You might have noticed that the VehicleClearingService's Lifetime was set to Lifetime = ServiceLifetime.Transient . The following lifetimes are available: Transient - The service gets recreated every time it gets resolved. Every resolution and injection of this service will have a unique instance. This is the default lifetime. Scoped - The service will share the same instance across the same command or event. Singleton - The service will only have one instance that lives as long as the OpenMod IoC container does (until OpenMod gets reloaded or the server shuts down). Built-in OpenMod services \u00b6 Service Description IConfiguration Read configuration files ICommandExecutor Execute command ICommandStore Access command registrations ICommandPermissionBuilder Get a command's permission ICurrentCommandContextAccessor Access the current command context IDataStore Serialize and deserialize persistent data IDataStoreFactory Create a data store instance IEventBus Subscribe to events and emit them IOpenModStringLocalizer Localize messages from OpenMod's translation file IOpenModDataStoreAccessor Access OpenMod's data store IOpenModHost OpenMod host platform abstractions IPermissionChecker Check permissions IPermissionRoleStore Get and manage permission roles IPluginAccessor<> Access a plugin's instance IPluginActivator Load and activate plugins IRuntime Manage OpenMod runtime IStringLocalizer Localize messages from plugin translation files IUserDataSeeder Seeds user data on first connect IUserDataStore Reads and saves user data IUserManager Finds and gets users Best Practices \u00b6 Do not make your services singleton unnecessarily. This may cause problems if your service has transient or scoped dependencies.","title":"Services"},{"location":"development-guide/services/#services-and-dependency-injection","text":"OpenMod, like other modern .NET projects, uses the dependency injection pattern . This guide aims to simplify it and explain what it means for plugin developers using OpenMod. Plugins, commands, event listeners, and services can automatically get references to plugins or any other services provided by OpenMod just by adding their interfaces to the constructor. See the example below.","title":"Services and dependency injection"},{"location":"development-guide/services/#dependency-injection-example","text":"Let's see this in action: This is how your plugin looks like normally: public class MyPlugin ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } If you wanted to access the IStringLocalizer service, you could it like this: public class MyPlugin ( IStringLocalizer stringLocalizer , IServiceProvider serviceProvider ) : base ( serviceProvider ) { // do something with stringLocalizer } Assume you want to access your plugin's instance and configuration from a command. Here is how you could do it: private readonly IConfiguration m_Configuration ; private readonly MyPlugin m_MyPlugin ; public EchoCommand ( IServiceProvider serviceProvider , MyPlugin myPlugin , IConfiguration configuration ) : base ( serviceProvider ) m_MyPlugin = myPlugin ; m_Configuration = configuration ; }","title":"Dependency injection example"},{"location":"development-guide/services/#registering-your-own-services","text":"There are two ways to register a service: Registering by using the [Service] attribute for the interface and [ServiceImplementation] for the concrete class. Registering manually by implementing the IServiceConfigurator or IContainerConfigurator interfaces. Classes which implement these interfaces are automatically instantiated when the IoC container is configured and can be used to configure the container directly. You can implement the IDisposable or the IAsyncDisposable interface for cleaning up resources when OpenMod reloads or shuts down. You can use the IPluginAccessor<> service, to access your plugins instance and its services. Here is an example service to clear vehicles: [Service] public interface IVehicleClearingService { Task ClearVehiclesAsync (); } [ServiceImplementation(Lifetime = ServiceLifetime.Transient)] public class VehicleClearingService : IVehicleClearingService , IAsyncDisposable { private readonly IStringLocalizer m_StringLocalizer ; private readonly ILogger < VehicleClearingService > m_Logger ; public VehicleClearingService ( ILogger < VehicleClearingService > logger , IPluginAccessor < VehicleClearerPlugin > pluginAccessor ) { VehicleClearerPlugin plugin = pluginAccessor . Instance ; // Services live in the global OpenMod scope, which does not provide an IStringLocalizer. // Since IStringLocalizer does not exist in this scope, we have to use the plugins scope. m_StringLocalizer = plugin . Lifetime . Resolve < IStringLocalizer >(); m_Logger = logger ; } public async Task ClearVehiclesAsync () { m_Logger . LogInformation ( m_StringLocalizer [ \"messages:clearing_vehicles\" ]); // translation is read from the plugins translation // call game apis to clear vehicles... } // Service dispose methods are called on OpenMod reload or server shutdown public async ValueTask DisposeAsync () { await ClearVehiclesAsync (); // ensure vehicles get cleared on reload or shutdown } } You can now access this service by injecting IVehicleClearingService in e.g. commands, event listeners, your plugin class, or other services. Note Custom services have a different lifetime than plugins. Even if your plugin unloads, your service will still be alive and used. Services are created before plugins load and are destroyed when openmod reloads or the server shuts down.","title":"Registering your own services"},{"location":"development-guide/services/#service-lifetime","text":"You might have noticed that the VehicleClearingService's Lifetime was set to Lifetime = ServiceLifetime.Transient . The following lifetimes are available: Transient - The service gets recreated every time it gets resolved. Every resolution and injection of this service will have a unique instance. This is the default lifetime. Scoped - The service will share the same instance across the same command or event. Singleton - The service will only have one instance that lives as long as the OpenMod IoC container does (until OpenMod gets reloaded or the server shuts down).","title":"Service lifetime"},{"location":"development-guide/services/#built-in-openmod-services","text":"Service Description IConfiguration Read configuration files ICommandExecutor Execute command ICommandStore Access command registrations ICommandPermissionBuilder Get a command's permission ICurrentCommandContextAccessor Access the current command context IDataStore Serialize and deserialize persistent data IDataStoreFactory Create a data store instance IEventBus Subscribe to events and emit them IOpenModStringLocalizer Localize messages from OpenMod's translation file IOpenModDataStoreAccessor Access OpenMod's data store IOpenModHost OpenMod host platform abstractions IPermissionChecker Check permissions IPermissionRoleStore Get and manage permission roles IPluginAccessor<> Access a plugin's instance IPluginActivator Load and activate plugins IRuntime Manage OpenMod runtime IStringLocalizer Localize messages from plugin translation files IUserDataSeeder Seeds user data on first connect IUserDataStore Reads and saves user data IUserManager Finds and gets users","title":"Built-in OpenMod services"},{"location":"development-guide/services/#best-practices","text":"Do not make your services singleton unnecessarily. This may cause problems if your service has transient or scoped dependencies.","title":"Best Practices"},{"location":"development-guide/events/builtin-events/","text":"Built-in OpenMod Events \u00b6 Event Fired when UserConnectingEvent A user attempts to connect to the server UserConnectedEvent A user has connected to the server UserDisconnectedEvent A user has disconnected from the server CommandExecutingEvent A command is going to be executed CommandExecutedEvent A command has been executed","title":"Built-in events"},{"location":"development-guide/events/builtin-events/#built-in-openmod-events","text":"Event Fired when UserConnectingEvent A user attempts to connect to the server UserConnectedEvent A user has connected to the server UserDisconnectedEvent A user has disconnected from the server CommandExecutingEvent A command is going to be executed CommandExecutedEvent A command has been executed","title":"Built-in OpenMod Events"},{"location":"development-guide/events/events/","text":"Events and event listeners \u00b6 Events are used to notify components that something is happening, like when a user disconnects. There are three types of events: OpenMod Events C# Events C# Delegates This guide will be about OpenMod events. Subscribing to events \u00b6 There are two ways to subscribe to events: Implement the IEventListener interface: public class UserConnectListener : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.Lowest)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { // do something } } Use the subscribe methods from the IEventBus service: public class MyPlugin : OpenModUniversalPlugin { private readonly IEventBus m_EventBus ; public MyPlugin ( IEventBus eventBus , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_EventBus = eventBus ; } public async Task OnLoadAsync () { m_EventBus . Subscribe ( this , ( sender , @event ) => { // do something }); } } Note All OpenMod event listeners are automatically unsubscribed when your plugin unloads. You do not have to unsubscribe them manually. Event listener priority and execution order \u00b6 OpenMod allows you to control in which order your event listeners are executed. Execution order is based on priority. You can set an event listeners priority by using the [EventListener] attribute. Execution order is from lowest priority to highest. In other words, lowest priority is called first. public class UserConnectListener1 : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.Lowest)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { } } public class UserConnectListener2 : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.Low)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { } } public class UserConnectListener3 : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.High)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { } } In the example above, UserConnectListener1 is called first, then UserConnectListener2 and finally UserConnectListener3 . Cancelling events and ignoring cancelled events \u00b6 An event has to implement the ICancellableEvent interface to be cancellable. If an event gets cancelled, event listeners which do not have the IgnoreCancelled property in the [EventListener] attribute set to true will not be notified. UserConnectingEvent is such a cancellable event. It will disconnect the connecting user if the event gets cancelled. public class UserConnectingListener1 : IEventListener < UserConnectingEvent > { [EventListener(Priority = Priority.Lowest)] public async Task HandleEventAsync ( object sender , UserConnectingEvent @event ) { if ( user . DisplayName . Equals ( \"Trojaner\" )) { @event . IsCancelled = true ; } } } public class UserConnectingListener2 : IEventListener < UserConnectingEvent > { [EventListener(Priority = Priority.Low)] public async Task HandleEventAsync ( object sender , UserConnectingEvent @event ) { // this event listener will not be called because it does not ignore cancellation } } public class UserConnectingListener3 : IEventListener < UserConnectingEvent > { [EventListener(Priority = Priority.High, IgnoreCancelled = true)] public async Task HandleEventAsync ( object sender , UserConnectingEvent @event ) { // this event listener will be called even if the event gets cancelled } } In the example above, if a user named \"Trojaner\" connects, UserConnectingListener1 will cancel the event. UserConnectingListener2 will not be called in this case because it does not ignore cancelled events like UserConnectingListener3 does. Event listener lifetime \u00b6 Event listeners can have three types of lifetime: Transient - The event listener is always be recreated on every event. If you have multiple IEventListeners, all of them will have their own instances. This is the default lifetime. Scoped - If you implement multiple IEventListeners in one class, all of them will share the same instance. Otherwise same as transient. Singleton - The event listener will have only one shared lifetime that lives until the plugin gets unloaded. You can set the event listener lifetime by adding the [EventListenerLifetime(ServiceLifetime)] attribute: [EventListenerLifetime(ServiceLifetime.Transient)] public class UserConnectBroadcaster : IEventListener < UserConnectedEvent > // ... Custom events \u00b6 Creating a custom event is simple: just create a new class that inherits from Event . Here is an example: public class SampleEvent : Event { public int MyValue { get ; set ; } // you can also add other properties } You can then emit it by using the event bus: MyPlugin myPlugin = ...; IEventBus eventBus = ...; ILogger < xxx > logger = ...; var @event = new SampleEvent { MyValue = 20 }; await m_EventBus . EmitAsync ( myPlugin , this /* sender */ , @event ); logger . LogInformation ( $ \"Event value: {@event.MyValue}\" ); If you want your event to be cancellable, you must implement the ICancellableEvent interface: public class SampleEvent : Event , ICancellableEvent { public int MyValue { get ; set ; } public bool IsCancelled { get ; set ; } } MyPlugin myPlugin = ...; IEventBus eventBus = ...; ILogger < xxx > logger = ...; var @event = new SampleEvent { MyValue = 20 }; await m_EventBus . EmitAsync ( myPlugin , this /* sender */ , @event ); if ( @event . IsCancelled ) { logger . LogInformation ( $ \"Event has been cancelled!\" ); return ; } logger . LogInformation ( $ \"Event value: {@event.MyValue}\" ); Best Practices \u00b6 Always unsubscribe from C# events and delegates when your plugin unloads or a service gets disposed. For example, if you want to subscribe to the onEnemyConnected event from Unturned when your plugin loads, you must do it like this: public async UniTask OnLoadAsync () { Provider . onEnemyConnected += OnPlayerConnected ; } public async UniTask OnUnloadAsync () { // this is very important, otherwise your plugin will not support reloads and unloads. Provider . onEnemyConnected -= OnPlayerConnected ; } Do not use the singleton lifetime for event listeners unnecessarily. This may cause problems if the event listener has transient or scoped dependencies.","title":"Events and event listeners"},{"location":"development-guide/events/events/#events-and-event-listeners","text":"Events are used to notify components that something is happening, like when a user disconnects. There are three types of events: OpenMod Events C# Events C# Delegates This guide will be about OpenMod events.","title":"Events and event listeners"},{"location":"development-guide/events/events/#subscribing-to-events","text":"There are two ways to subscribe to events: Implement the IEventListener interface: public class UserConnectListener : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.Lowest)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { // do something } } Use the subscribe methods from the IEventBus service: public class MyPlugin : OpenModUniversalPlugin { private readonly IEventBus m_EventBus ; public MyPlugin ( IEventBus eventBus , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_EventBus = eventBus ; } public async Task OnLoadAsync () { m_EventBus . Subscribe ( this , ( sender , @event ) => { // do something }); } } Note All OpenMod event listeners are automatically unsubscribed when your plugin unloads. You do not have to unsubscribe them manually.","title":"Subscribing to events"},{"location":"development-guide/events/events/#event-listener-priority-and-execution-order","text":"OpenMod allows you to control in which order your event listeners are executed. Execution order is based on priority. You can set an event listeners priority by using the [EventListener] attribute. Execution order is from lowest priority to highest. In other words, lowest priority is called first. public class UserConnectListener1 : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.Lowest)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { } } public class UserConnectListener2 : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.Low)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { } } public class UserConnectListener3 : IEventListener < UserConnectedEvent > { [EventListener(Priority = Priority.High)] public async Task HandleEventAsync ( object sender , UserConnectEvent @event ) { } } In the example above, UserConnectListener1 is called first, then UserConnectListener2 and finally UserConnectListener3 .","title":"Event listener priority and execution order"},{"location":"development-guide/events/events/#cancelling-events-and-ignoring-cancelled-events","text":"An event has to implement the ICancellableEvent interface to be cancellable. If an event gets cancelled, event listeners which do not have the IgnoreCancelled property in the [EventListener] attribute set to true will not be notified. UserConnectingEvent is such a cancellable event. It will disconnect the connecting user if the event gets cancelled. public class UserConnectingListener1 : IEventListener < UserConnectingEvent > { [EventListener(Priority = Priority.Lowest)] public async Task HandleEventAsync ( object sender , UserConnectingEvent @event ) { if ( user . DisplayName . Equals ( \"Trojaner\" )) { @event . IsCancelled = true ; } } } public class UserConnectingListener2 : IEventListener < UserConnectingEvent > { [EventListener(Priority = Priority.Low)] public async Task HandleEventAsync ( object sender , UserConnectingEvent @event ) { // this event listener will not be called because it does not ignore cancellation } } public class UserConnectingListener3 : IEventListener < UserConnectingEvent > { [EventListener(Priority = Priority.High, IgnoreCancelled = true)] public async Task HandleEventAsync ( object sender , UserConnectingEvent @event ) { // this event listener will be called even if the event gets cancelled } } In the example above, if a user named \"Trojaner\" connects, UserConnectingListener1 will cancel the event. UserConnectingListener2 will not be called in this case because it does not ignore cancelled events like UserConnectingListener3 does.","title":"Cancelling events and ignoring cancelled events"},{"location":"development-guide/events/events/#event-listener-lifetime","text":"Event listeners can have three types of lifetime: Transient - The event listener is always be recreated on every event. If you have multiple IEventListeners, all of them will have their own instances. This is the default lifetime. Scoped - If you implement multiple IEventListeners in one class, all of them will share the same instance. Otherwise same as transient. Singleton - The event listener will have only one shared lifetime that lives until the plugin gets unloaded. You can set the event listener lifetime by adding the [EventListenerLifetime(ServiceLifetime)] attribute: [EventListenerLifetime(ServiceLifetime.Transient)] public class UserConnectBroadcaster : IEventListener < UserConnectedEvent > // ...","title":"Event listener lifetime"},{"location":"development-guide/events/events/#custom-events","text":"Creating a custom event is simple: just create a new class that inherits from Event . Here is an example: public class SampleEvent : Event { public int MyValue { get ; set ; } // you can also add other properties } You can then emit it by using the event bus: MyPlugin myPlugin = ...; IEventBus eventBus = ...; ILogger < xxx > logger = ...; var @event = new SampleEvent { MyValue = 20 }; await m_EventBus . EmitAsync ( myPlugin , this /* sender */ , @event ); logger . LogInformation ( $ \"Event value: {@event.MyValue}\" ); If you want your event to be cancellable, you must implement the ICancellableEvent interface: public class SampleEvent : Event , ICancellableEvent { public int MyValue { get ; set ; } public bool IsCancelled { get ; set ; } } MyPlugin myPlugin = ...; IEventBus eventBus = ...; ILogger < xxx > logger = ...; var @event = new SampleEvent { MyValue = 20 }; await m_EventBus . EmitAsync ( myPlugin , this /* sender */ , @event ); if ( @event . IsCancelled ) { logger . LogInformation ( $ \"Event has been cancelled!\" ); return ; } logger . LogInformation ( $ \"Event value: {@event.MyValue}\" );","title":"Custom events"},{"location":"development-guide/events/events/#best-practices","text":"Always unsubscribe from C# events and delegates when your plugin unloads or a service gets disposed. For example, if you want to subscribe to the onEnemyConnected event from Unturned when your plugin loads, you must do it like this: public async UniTask OnLoadAsync () { Provider . onEnemyConnected += OnPlayerConnected ; } public async UniTask OnUnloadAsync () { // this is very important, otherwise your plugin will not support reloads and unloads. Provider . onEnemyConnected -= OnPlayerConnected ; } Do not use the singleton lifetime for event listeners unnecessarily. This may cause problems if the event listener has transient or scoped dependencies.","title":"Best Practices"},{"location":"development-guide/events/game-events/","text":"Game Events \u00b6 These events are provided by the OpenMod.Games.Abstractions package and are not part of the core OpenMod API. They may not be available on all supported OpenMod platforms. Note The OpenMod.Games.Abstractions is not available yet.","title":"Game events"},{"location":"development-guide/events/game-events/#game-events","text":"These events are provided by the OpenMod.Games.Abstractions package and are not part of the core OpenMod API. They may not be available on all supported OpenMod platforms. Note The OpenMod.Games.Abstractions is not available yet.","title":"Game Events"},{"location":"user-guide/configurations/","text":"Configurations \u00b6 OpenMod uses YAML for configurations. You can find a quick YAML guide here . Plugin specific configurations are stored in the plugins/<plugin id> directory. Note Configuration files are currently not updated automatically. If OpenMod or a plugin adds a new field, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Configurations"},{"location":"user-guide/configurations/#configurations","text":"OpenMod uses YAML for configurations. You can find a quick YAML guide here . Plugin specific configurations are stored in the plugins/<plugin id> directory. Note Configuration files are currently not updated automatically. If OpenMod or a plugin adds a new field, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Configurations"},{"location":"user-guide/localization/","text":"Localization \u00b6 Translations files allow you to translate or customize OpenMod or plugin messages. OpenMod's translation file openmod.translations.yaml can be found inside the OpenMod directory: commands : openmod : restricted : \"This command is restricted.\" errors : out_of_range_error : \"Too few arguments: missing parameter at index {Index} of type {Type.Name}\" parse_error : \"Parse error: could not parse {Value} to {Type.Name}\" not_found : \"Command was not found: {CommandName}\" wrong_usage : \"Wrong command usage. Correct usage: {Command} {Syntax}\" OpenMod uses SmartFormat.NET for parsing translation arguments. See the SmartFormat.NET wiki for more information. Note Translation files are currently not updated automatically. If OpenMod or a plugin adds a new translation, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Localization"},{"location":"user-guide/localization/#localization","text":"Translations files allow you to translate or customize OpenMod or plugin messages. OpenMod's translation file openmod.translations.yaml can be found inside the OpenMod directory: commands : openmod : restricted : \"This command is restricted.\" errors : out_of_range_error : \"Too few arguments: missing parameter at index {Index} of type {Type.Name}\" parse_error : \"Parse error: could not parse {Value} to {Type.Name}\" not_found : \"Command was not found: {CommandName}\" wrong_usage : \"Wrong command usage. Correct usage: {Command} {Syntax}\" OpenMod uses SmartFormat.NET for parsing translation arguments. See the SmartFormat.NET wiki for more information. Note Translation files are currently not updated automatically. If OpenMod or a plugin adds a new translation, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Localization"},{"location":"user-guide/logging/","text":"Logging \u00b6 OpenMod uses Serilog as the default logger implementation. Serilog is configured through the logging.yaml in the OpenMod directory. You can find the documentation for the Serilog configuration here (you will have to convert from json to yaml). Serilog supports many sinks as logging target. You can install new sinks via the openmod install <package id> command and configure them in the logging.yaml. For example, this is how you would configure logging to MySQL/MariaDB instead to file: Install the MariaDB Sink: openmod install Serilog.Sinks.MariaDB Add the MariaDB Sink to the logging.yaml: Serilog : Using : - Serilog - Serilog.Sinks.Console - Serilog.Sinks.File - Serilog.Sinks.Async - Serilog.Sinks.MariaDB # Do not forget to add your sink here WriteTo : - Name : Async # By default OpenMod logs async for performance reasons Args : configure : - Name : MariaDB Args : connectionString : \"server=...\" , # See https://www.connectionstrings.com/mysql/ tableName : \"logs\" , autoCreateTable : true - Name : Console Args : theme : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" outputTemplate : \"[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}\" Enrich : - FromLogContext MinimumLevel : Default : Information # Only log Information or higher by default Override : # You can configure when specific events should be logged # In this example, the Microsoft.EntityFrameworkCore events below are only logged if Warning or higher Microsoft.EntityFrameworkCore.Database.Command : Warning Microsoft.EntityFrameworkCore.Infrastructure : Warning Microsoft.EntityFrameworkCore.Database.Connection : Warning Microsoft.EntityFrameworkCore.Query : Warning","title":"Logging"},{"location":"user-guide/logging/#logging","text":"OpenMod uses Serilog as the default logger implementation. Serilog is configured through the logging.yaml in the OpenMod directory. You can find the documentation for the Serilog configuration here (you will have to convert from json to yaml). Serilog supports many sinks as logging target. You can install new sinks via the openmod install <package id> command and configure them in the logging.yaml. For example, this is how you would configure logging to MySQL/MariaDB instead to file: Install the MariaDB Sink: openmod install Serilog.Sinks.MariaDB Add the MariaDB Sink to the logging.yaml: Serilog : Using : - Serilog - Serilog.Sinks.Console - Serilog.Sinks.File - Serilog.Sinks.Async - Serilog.Sinks.MariaDB # Do not forget to add your sink here WriteTo : - Name : Async # By default OpenMod logs async for performance reasons Args : configure : - Name : MariaDB Args : connectionString : \"server=...\" , # See https://www.connectionstrings.com/mysql/ tableName : \"logs\" , autoCreateTable : true - Name : Console Args : theme : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" outputTemplate : \"[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}\" Enrich : - FromLogContext MinimumLevel : Default : Information # Only log Information or higher by default Override : # You can configure when specific events should be logged # In this example, the Microsoft.EntityFrameworkCore events below are only logged if Warning or higher Microsoft.EntityFrameworkCore.Database.Command : Warning Microsoft.EntityFrameworkCore.Infrastructure : Warning Microsoft.EntityFrameworkCore.Database.Connection : Warning Microsoft.EntityFrameworkCore.Query : Warning","title":"Logging"},{"location":"user-guide/permissions/","text":"Permissions \u00b6 OpenMod has a simple role-based permission system. Permissions define which actions a user can execute and which they cannot. You can manage permissions by editing the openmod.roles.yaml file inside the OpenMod directory or by using the permission and permissionrole commands. You can use the help permission and help permissionrole commands for more information. Permission roles \u00b6 Roles are basically a group of permissions and other attributes. If you assign a role to a user, they will automatically inherit all permissions of the role. You can also add parent roles to a role so they can inherit permissions. A role has the following attributes: Parents : The parent roles, whose permissions are inherited. Permissions : List of permissions the role has. Display Name : Human-readable name of the role. Is Auto Assigned : Automatically assigns the role to new users. Does not assign to existing users . Data : Data that can be attached to the role by plugins. Priority : In case of conflicting permissions, this attribute will define which role gets preferred. Creating permission roles \u00b6 Open the openmod.roles.yaml file. You will see something similar to this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip priority : 1 parents : - default - home - tp permissions : - kit.vip data : {} This list contains 2 roles: default and vip . As you may have noticed, the - adds a new role. To add a new role, simply copy the default role and add it like this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip displayName : VIP priority : 1 parents : - default permissions : - kit.vip - home - tp data : {} - id : megavip displayName : Mega VIP priority : 1 parents : - vip permissions : - kit.megavip data : {} Note You can also add and remove parent roles with the permissionrole command: permissionrole add role megavip vip Removing roles \u00b6 Just remove the role from the openmod.roles.yaml file. Managing role permissions \u00b6 From the earlier example, the megavip role has the following permissions: - help (inherited from default, which is a parent of vip) - kit.vip (inherited from vip) - kit.megavip What if we want it to have vip as parent, but do not want it to inherit the kit.vip permission? In that case, we can negate the permission by adding it prefixed with a \"!\": - id: megavip displayName: Mega VIP priority: 1 parents: - default - vip permissions: - !kit.vip # Forcefully removes \"kit.vip\", even if inherited - kit.megavip data: {} Note You can also add and remove permissions with the permission command: permission add role megavip !kit.vip User permissions and user roles \u00b6 You can assign users to roles via the permissionrole add player <player> <role> command, e.g. permissionrole add player Trojaner megavip . The same way, you can remove users from a role with `permissionrole remove player <player> <role> Users can also have permissions directly attached to them: permission add player Trojaner kit.vip . User permissions always override any conflicting role permissions. Use permission remove to remove the permission again. Permission wildcards \u00b6 Assume a teleport plugin has the following permissions: teleport teleport.bring teleport.bring.request teleport.request Instead of adding all of these one by one, you can use the * wildcard to add all of them: teleport.* This will grant all permissions from above. Note Just adding the teleport permission will not grant the child permissions, e.g. teleport.bring. Finding command permissions \u00b6 If you do not know what permission a command requires, you can use help <command> to find it. Permissions for subcommands are not granted automatically and must be given either by using wildcards on the parent command permission or by specifying them directly.","title":"Permissions"},{"location":"user-guide/permissions/#permissions","text":"OpenMod has a simple role-based permission system. Permissions define which actions a user can execute and which they cannot. You can manage permissions by editing the openmod.roles.yaml file inside the OpenMod directory or by using the permission and permissionrole commands. You can use the help permission and help permissionrole commands for more information.","title":"Permissions"},{"location":"user-guide/permissions/#permission-roles","text":"Roles are basically a group of permissions and other attributes. If you assign a role to a user, they will automatically inherit all permissions of the role. You can also add parent roles to a role so they can inherit permissions. A role has the following attributes: Parents : The parent roles, whose permissions are inherited. Permissions : List of permissions the role has. Display Name : Human-readable name of the role. Is Auto Assigned : Automatically assigns the role to new users. Does not assign to existing users . Data : Data that can be attached to the role by plugins. Priority : In case of conflicting permissions, this attribute will define which role gets preferred.","title":"Permission roles"},{"location":"user-guide/permissions/#creating-permission-roles","text":"Open the openmod.roles.yaml file. You will see something similar to this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip priority : 1 parents : - default - home - tp permissions : - kit.vip data : {} This list contains 2 roles: default and vip . As you may have noticed, the - adds a new role. To add a new role, simply copy the default role and add it like this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip displayName : VIP priority : 1 parents : - default permissions : - kit.vip - home - tp data : {} - id : megavip displayName : Mega VIP priority : 1 parents : - vip permissions : - kit.megavip data : {} Note You can also add and remove parent roles with the permissionrole command: permissionrole add role megavip vip","title":"Creating permission roles"},{"location":"user-guide/permissions/#removing-roles","text":"Just remove the role from the openmod.roles.yaml file.","title":"Removing roles"},{"location":"user-guide/permissions/#managing-role-permissions","text":"From the earlier example, the megavip role has the following permissions: - help (inherited from default, which is a parent of vip) - kit.vip (inherited from vip) - kit.megavip What if we want it to have vip as parent, but do not want it to inherit the kit.vip permission? In that case, we can negate the permission by adding it prefixed with a \"!\": - id: megavip displayName: Mega VIP priority: 1 parents: - default - vip permissions: - !kit.vip # Forcefully removes \"kit.vip\", even if inherited - kit.megavip data: {} Note You can also add and remove permissions with the permission command: permission add role megavip !kit.vip","title":"Managing role permissions"},{"location":"user-guide/permissions/#user-permissions-and-user-roles","text":"You can assign users to roles via the permissionrole add player <player> <role> command, e.g. permissionrole add player Trojaner megavip . The same way, you can remove users from a role with `permissionrole remove player <player> <role> Users can also have permissions directly attached to them: permission add player Trojaner kit.vip . User permissions always override any conflicting role permissions. Use permission remove to remove the permission again.","title":"User permissions and user roles"},{"location":"user-guide/permissions/#permission-wildcards","text":"Assume a teleport plugin has the following permissions: teleport teleport.bring teleport.bring.request teleport.request Instead of adding all of these one by one, you can use the * wildcard to add all of them: teleport.* This will grant all permissions from above. Note Just adding the teleport permission will not grant the child permissions, e.g. teleport.bring.","title":"Permission wildcards"},{"location":"user-guide/permissions/#finding-command-permissions","text":"If you do not know what permission a command requires, you can use help <command> to find it. Permissions for subcommands are not granted automatically and must be given either by using wildcards on the parent command permission or by specifying them directly.","title":"Finding command permissions"},{"location":"user-guide/installation/auto-updates/","text":"Managing Auto-Updates \u00b6 By default, OpenMod automatically updates itself on each server start. You can change this behavior by doing any of these: Start server with -NoOpenModAutoUpdate argument. Set OpenMod_EnableAutoUpdate environment variable to false . OpenMod will always download its core components on the first start.","title":"Managing Auto Updates"},{"location":"user-guide/installation/auto-updates/#managing-auto-updates","text":"By default, OpenMod automatically updates itself on each server start. You can change this behavior by doing any of these: Start server with -NoOpenModAutoUpdate argument. Set OpenMod_EnableAutoUpdate environment variable to false . OpenMod will always download its core components on the first start.","title":"Managing Auto-Updates"},{"location":"user-guide/installation/unturned/","text":"Installing OpenMod for Unturned \u00b6 If you are running on a Linux system, install the libgdiplus package. Download the latest OpenMod.Unturned.Module-vX.X.X.zip from here . Copy the \"OpenMod.Unturned\" folder into the \"Modules\" folder inside the Unturned installation directory. Start your server. The first start will take a while since OpenMod will download its core components. OpenMod supports RocketMod plugins. Read the RocketMod Migration Guide if you are migrating from RocketMod. Done! Now you can start installing plugins . Using OpenMod on multiple servers sharing the same Unturned instance \u00b6 If you want to use OpenMod for multiple Unturned servers sharing the same Unturned instance, you must adjust the logging.yaml file. By default, Serilog logs to the logs/openmod.log file: - Name : File Args : path : logs/openmod.log This works great if you use only one server per Unturned instance. If you have multiple servers sharing the same instance, this would result in all servers sharing the same log file. To fix this issue, adjust the value to include the servers name. E.g.: - Name : File Args : path : logs/openmod-myserver.log You must repeat this for each server.","title":"Installing OpenMod for Unturned"},{"location":"user-guide/installation/unturned/#installing-openmod-for-unturned","text":"If you are running on a Linux system, install the libgdiplus package. Download the latest OpenMod.Unturned.Module-vX.X.X.zip from here . Copy the \"OpenMod.Unturned\" folder into the \"Modules\" folder inside the Unturned installation directory. Start your server. The first start will take a while since OpenMod will download its core components. OpenMod supports RocketMod plugins. Read the RocketMod Migration Guide if you are migrating from RocketMod. Done! Now you can start installing plugins .","title":"Installing OpenMod for Unturned"},{"location":"user-guide/installation/unturned/#using-openmod-on-multiple-servers-sharing-the-same-unturned-instance","text":"If you want to use OpenMod for multiple Unturned servers sharing the same Unturned instance, you must adjust the logging.yaml file. By default, Serilog logs to the logs/openmod.log file: - Name : File Args : path : logs/openmod.log This works great if you use only one server per Unturned instance. If you have multiple servers sharing the same instance, this would result in all servers sharing the same log file. To fix this issue, adjust the value to include the servers name. E.g.: - Name : File Args : path : logs/openmod-myserver.log You must repeat this for each server.","title":"Using OpenMod on multiple servers sharing the same Unturned instance"},{"location":"user-guide/migration/rocketmod/","text":"Migrating from RocketMod to OpenMod \u00b6 OpenMod has built-in support for RocketMod plugins. Most RocketMod plugins should work without the need for workarounds or rewrites. To use RocketMod plugins, follow these steps: After installing OpenMod for Unturned , remove the \"Rocket.Unturned\" folder from the \"Modules\" folder inside Unturned. If you were using RocketMod before, keep the \"Rocket\" folder inside your server's folder. Start your server, wait for OpenMod to load, and then install the OpenMod RocketMod Bridge : openmod install OpenMod.Rocket.Unturned . To finish migrating, restart your server or reload OpenMod: openmod reload . Using the OpenMod RocketMod Bridge \u00b6 You can use the OpenMod RocketMod Bridge exactly like the RocketMod module. For example, to install RocketMod plugins just add the dll files to your Rocket/Plugins folder inside your server's folder and restart or reload RocketMod: rocketmod reload . Caveats \u00b6 RocketMod plugins are not converted to OpenMod plugins, so you can not manage them from OpenMod. RocketMod is completely separated from OpenMod and has its own configuration system, permissions system, command system, etc. OpenMod commands will always override RocketMod commands when a conflict occurs. Linking RocketMod to OpenMod Permissions \u00b6 By default, the OpenMod RocketMod Bridge will use RocketMod's Permissions.xml when handling permissions for RocketMod plugins. This might be a problem as you would have to maintain two different permission systems. The RocketMod Permission Link plugin solves this issue by forcing RocketMod to use OpenMod's permission system. Keep in mind that it may not be compatible with other permissions plugins for RocketMod. To install the RocketMod Permission Link plugin, run openmod install OpenMod.Rocket.PermissionLink and then reload or restart. Differences between the OpenMod RocketMod Bridge and RocketMod \u00b6 The OpenMod RocketMod Bridge is based on a patched version of the LDM RocketMod fork , it is not a reimplementation of the RocketMod API. This will ensure compatibility with most RocketMod plugins, including those which access private RocketMod fields via reflection. The OpenMod RocketMod Bridge is an OpenMod plugin instead of a standalone Unturned module. RocketMod does not support unloading at runtime, as it never unbinds from events. With OpenMod, you can completely unload RocketMod or OpenMod at runtime. RocketMod's command handling has been patched to utilize OpenMod's command system to avoid conflicting commands. RocketMod's logging system has been patched to proxy to OpenMod's logging system (Serilog).","title":"Migrating from RocketMod"},{"location":"user-guide/migration/rocketmod/#migrating-from-rocketmod-to-openmod","text":"OpenMod has built-in support for RocketMod plugins. Most RocketMod plugins should work without the need for workarounds or rewrites. To use RocketMod plugins, follow these steps: After installing OpenMod for Unturned , remove the \"Rocket.Unturned\" folder from the \"Modules\" folder inside Unturned. If you were using RocketMod before, keep the \"Rocket\" folder inside your server's folder. Start your server, wait for OpenMod to load, and then install the OpenMod RocketMod Bridge : openmod install OpenMod.Rocket.Unturned . To finish migrating, restart your server or reload OpenMod: openmod reload .","title":"Migrating from RocketMod to OpenMod"},{"location":"user-guide/migration/rocketmod/#using-the-openmod-rocketmod-bridge","text":"You can use the OpenMod RocketMod Bridge exactly like the RocketMod module. For example, to install RocketMod plugins just add the dll files to your Rocket/Plugins folder inside your server's folder and restart or reload RocketMod: rocketmod reload .","title":"Using the OpenMod RocketMod Bridge"},{"location":"user-guide/migration/rocketmod/#caveats","text":"RocketMod plugins are not converted to OpenMod plugins, so you can not manage them from OpenMod. RocketMod is completely separated from OpenMod and has its own configuration system, permissions system, command system, etc. OpenMod commands will always override RocketMod commands when a conflict occurs.","title":"Caveats"},{"location":"user-guide/migration/rocketmod/#linking-rocketmod-to-openmod-permissions","text":"By default, the OpenMod RocketMod Bridge will use RocketMod's Permissions.xml when handling permissions for RocketMod plugins. This might be a problem as you would have to maintain two different permission systems. The RocketMod Permission Link plugin solves this issue by forcing RocketMod to use OpenMod's permission system. Keep in mind that it may not be compatible with other permissions plugins for RocketMod. To install the RocketMod Permission Link plugin, run openmod install OpenMod.Rocket.PermissionLink and then reload or restart.","title":"Linking RocketMod to OpenMod Permissions"},{"location":"user-guide/migration/rocketmod/#differences-between-the-openmod-rocketmod-bridge-and-rocketmod","text":"The OpenMod RocketMod Bridge is based on a patched version of the LDM RocketMod fork , it is not a reimplementation of the RocketMod API. This will ensure compatibility with most RocketMod plugins, including those which access private RocketMod fields via reflection. The OpenMod RocketMod Bridge is an OpenMod plugin instead of a standalone Unturned module. RocketMod does not support unloading at runtime, as it never unbinds from events. With OpenMod, you can completely unload RocketMod or OpenMod at runtime. RocketMod's command handling has been patched to utilize OpenMod's command system to avoid conflicting commands. RocketMod's logging system has been patched to proxy to OpenMod's logging system (Serilog).","title":"Differences between the OpenMod RocketMod Bridge and RocketMod"},{"location":"user-guide/plugins/plugin-management/","text":"Installing and Managing Plugins \u00b6 OpenMod provides commands to download, install, update, and remove plugins at runtime. Note You must restart the server or reload OpenMod with openmod reload after doing any changes to installed plugins. Finding Plugins \u00b6 You can find a list of plugins at the openmod-plugins repository . You can also search for openmod-plugin on nuget.org . Installing Plugins \u00b6 There are two ways to install plugins by default: To install plugins from NuGet, install them via the openmod install <package id> command, e.g. openmod install OpenMod.Rocket.Unturned . You can also install specific versions via the openmod install <package id> <version> command. For pre release versions, add the -Pre option: openmod install <package id> -Pre or openmod install <package id> <version> -Pre . To install plugins manually, move the plugin dll file and all libraries of the plugin to the openmod/plugins directory. You can also install the libraries with openmod install <package-id> instead. Updating Plugins \u00b6 If you installed the plugin via openmod install , you can simply update it using openmod update <package id> . Like with openmod install , you can specify the version and use -Pre for pre release versions. If you installed the plugin directly as a dll file, you can replace the old .dll file with the updated one. Removing Plugins \u00b6 If you installed the plugin via openmod install , you can simply remove it by using openmod remove <package id> . If you installed the plugin directly as a dll file, you can just delete the .dll file.","title":"Installing and managing plugins"},{"location":"user-guide/plugins/plugin-management/#installing-and-managing-plugins","text":"OpenMod provides commands to download, install, update, and remove plugins at runtime. Note You must restart the server or reload OpenMod with openmod reload after doing any changes to installed plugins.","title":"Installing and Managing Plugins"},{"location":"user-guide/plugins/plugin-management/#finding-plugins","text":"You can find a list of plugins at the openmod-plugins repository . You can also search for openmod-plugin on nuget.org .","title":"Finding Plugins"},{"location":"user-guide/plugins/plugin-management/#installing-plugins","text":"There are two ways to install plugins by default: To install plugins from NuGet, install them via the openmod install <package id> command, e.g. openmod install OpenMod.Rocket.Unturned . You can also install specific versions via the openmod install <package id> <version> command. For pre release versions, add the -Pre option: openmod install <package id> -Pre or openmod install <package id> <version> -Pre . To install plugins manually, move the plugin dll file and all libraries of the plugin to the openmod/plugins directory. You can also install the libraries with openmod install <package-id> instead.","title":"Installing Plugins"},{"location":"user-guide/plugins/plugin-management/#updating-plugins","text":"If you installed the plugin via openmod install , you can simply update it using openmod update <package id> . Like with openmod install , you can specify the version and use -Pre for pre release versions. If you installed the plugin directly as a dll file, you can replace the old .dll file with the updated one.","title":"Updating Plugins"},{"location":"user-guide/plugins/plugin-management/#removing-plugins","text":"If you installed the plugin via openmod install , you can simply remove it by using openmod remove <package id> . If you installed the plugin directly as a dll file, you can just delete the .dll file.","title":"Removing Plugins"}]}